*** linux-3.2.13/drivers/uio/uio_pci_generic.c.orig	2012-12-21 09:47:28.290592000 -0800
--- linux-3.2.13/drivers/uio/uio_pci_generic.c	2012-12-21 09:51:21.389282000 -0800
***************
*** 27,33 ****
  
  #define DRIVER_VERSION	"0.01.0"
  #define DRIVER_AUTHOR	"Michael S. Tsirkin <mst@redhat.com>"
! #define DRIVER_DESC	"Generic UIO driver for PCI 2.3 devices"
  
  struct uio_pci_generic_dev {
  	struct uio_info info;
--- 27,33 ----
  
  #define DRIVER_VERSION	"0.01.0"
  #define DRIVER_AUTHOR	"Michael S. Tsirkin <mst@redhat.com>"
! #define DRIVER_DESC	"Generic UIO driver for PCI 2.3 devices (modified by T.S.)"
  
  struct uio_pci_generic_dev {
  	struct uio_info info;
***************
*** 118,128 ****
--- 118,201 ----
  	return err;
  }
  
+ /* From Tom Lyon's patch */
+ static void uio_do_maps(struct uio_pci_generic_dev *gdev)
+ {
+ 	struct pci_dev *pdev = gdev->pdev;
+ 	struct uio_info *info = &gdev->info;
+ 	int i, j;
+ 	char *name;
+ 
+ 	for (i = 0, j = 0; i < PCI_STD_RESOURCE_END && j < MAX_UIO_MAPS; i++) {
+ 		if (pci_resource_flags(pdev, i) & IORESOURCE_MEM) {
+ 			/* second test should never be possible but be paranoid... */
+ 			if ( pci_resource_len(pdev, i) < PAGE_SIZE || (pci_resource_start(pdev, i) & (PAGE_SIZE - 1 )) ) {
+ 				/* disallow smaller mappings as this could create security problems
+ 				 * (other device's resource in the same page
+ 				 */
+ 				dev_warn( &pdev->dev,
+ 				          "Memory resource %i @08x%llx:0x%04llx not page-aligned;"
+                           " refuse to map. Use 'pci=resource_alignment=' kernel option for this device\n",
+ 				          i,
+ 				          (unsigned long long)pci_resource_start(pdev, i),
+ 				          (unsigned long long)pci_resource_len(pdev, i) );
+ 				continue;
+ 			}
+ 			name = kmalloc(8, GFP_KERNEL);
+ 			if (name == NULL)
+ 				break;
+ 			sprintf(name, "membar%d", i);
+ 			info->mem[j].name = name;
+ 			info->mem[j].addr = pci_resource_start(pdev, i);
+ 			dev_warn( &pdev->dev, "TSILL adding membar%i @0x08%llx\n", i, (unsigned long long)pci_resource_start(pdev, i));
+ 			info->mem[j].size = pci_resource_len(pdev, i);
+ 			info->mem[j].memtype = UIO_MEM_PHYS;
+ 			j++;
+ 		}
+ 	}
+ 	for (i = 0, j = 0; i < PCI_STD_RESOURCE_END &&
+ 			j < MAX_UIO_PORT_REGIONS; i++) {
+ 		if (pci_resource_flags(pdev, i) & IORESOURCE_IO) {
+ 			name = kmalloc(8, GFP_KERNEL);
+ 			if (name == NULL)
+ 				break;
+ 			sprintf(name, "iobar%d", i);
+ 			info->port[j].name = name;
+ 			info->port[j].start = pci_resource_start(pdev, i);
+ 			info->port[j].size = pci_resource_len(pdev, i);
+ 			info->port[j].porttype = UIO_PORT_X86;
+ 			j++;
+ 		}
+ 	}
+ }
+ 
+ static void uio_free_names(struct uio_pci_generic_dev *gdev)
+ {
+ int i;
+ 	for ( i=0; i < MAX_UIO_MAPS; i++ ) {
+ 		if ( gdev->info.mem[i].name ) {
+ 			kfree( gdev->info.mem[i].name );
+ 			gdev->info.mem[i].name    = 0;
+ 			gdev->info.mem[i].memtype = 0;
+ 		}
+ 	}
+ 	for ( i=0; i < MAX_UIO_PORT_REGIONS; i++ ) {
+ 		if ( gdev->info.port[i].name ) {
+ 			kfree( gdev->info.port[i].name );
+ 			gdev->info.port[i].name     = 0;
+ 			gdev->info.port[i].porttype = 0;
+ 		}
+ 	}
+ }
+ 
  static int __devinit probe(struct pci_dev *pdev,
  			   const struct pci_device_id *id)
  {
  	struct uio_pci_generic_dev *gdev;
  	int err;
+ #ifndef TSILL
+ 	int irq;
+ #endif
  
  	err = pci_enable_device(pdev);
  	if (err) {
***************
*** 131,144 ****
  		return err;
  	}
  
! 	if (!pdev->irq) {
  		dev_warn(&pdev->dev, "No IRQ assigned to device: "
  			 "no support for interrupts?\n");
  		pci_disable_device(pdev);
  		return -ENODEV;
  	}
! 
  	err = verify_pci_2_3(pdev);
  	if (err)
  		goto err_verify;
  
--- 204,233 ----
  		return err;
  	}
  
! 	if (!(irq = pdev->irq)) {
  		dev_warn(&pdev->dev, "No IRQ assigned to device: "
  			 "no support for interrupts?\n");
+ 		dev_warn(&pdev->dev, "TSILL phase 1.\n");
+ #ifdef TSILL
  		pci_disable_device(pdev);
  		return -ENODEV;
+ #else
+ 		dev_warn(&pdev->dev, "TSILL phase 2.\n");
+ 		err = 0;
+ #endif
  	}
! #ifndef TSILL
! 	else {
! #endif
  	err = verify_pci_2_3(pdev);
+ #ifndef TSILL
+ 		dev_warn(&pdev->dev, "Not PCI-2.3 compliant! "
+ 			 "no support for interrupts!\n");
+ 		err = 0;
+ 		irq = 0;
+ 	}
+ #endif
+ 
  	if (err)
  		goto err_verify;
  
***************
*** 150,166 ****
  
  	gdev->info.name = "uio_pci_generic";
  	gdev->info.version = DRIVER_VERSION;
! 	gdev->info.irq = pdev->irq;
  	gdev->info.irq_flags = IRQF_SHARED;
  	gdev->info.handler = irqhandler;
  	gdev->pdev = pdev;
  
  	if (uio_register_device(&pdev->dev, &gdev->info))
  		goto err_register;
  	pci_set_drvdata(pdev, gdev);
  
  	return 0;
  err_register:
  	kfree(gdev);
  err_alloc:
  err_verify:
--- 239,258 ----
  
  	gdev->info.name = "uio_pci_generic";
  	gdev->info.version = DRIVER_VERSION;
! 	gdev->info.irq = irq;
  	gdev->info.irq_flags = IRQF_SHARED;
  	gdev->info.handler = irqhandler;
  	gdev->pdev = pdev;
  
+ 	uio_do_maps(gdev);
+ 
  	if (uio_register_device(&pdev->dev, &gdev->info))
  		goto err_register;
  	pci_set_drvdata(pdev, gdev);
  
  	return 0;
  err_register:
+ 	uio_free_names(gdev);
  	kfree(gdev);
  err_alloc:
  err_verify:
***************
*** 174,179 ****
--- 266,272 ----
  
  	uio_unregister_device(&gdev->info);
  	pci_disable_device(pdev);
+ 	uio_free_names(gdev);
  	kfree(gdev);
  }
  
