*** drivers/uio/uio_pci_generic.c.orig	2012-04-17 20:19:16.000000000 -0500
--- drivers/uio/uio_pci_generic.c	2012-04-20 00:51:59.000000000 -0500
***************
*** 28,34 ****
  
  #define DRIVER_VERSION	"0.01.0"
  #define DRIVER_AUTHOR	"Michael S. Tsirkin <mst@redhat.com>"
! #define DRIVER_DESC	"Generic UIO driver for PCI 2.3 devices"
  
  struct uio_pci_generic_dev {
  	struct uio_info info;
--- 28,34 ----
  
  #define DRIVER_VERSION	"0.01.0"
  #define DRIVER_AUTHOR	"Michael S. Tsirkin <mst@redhat.com>"
! #define DRIVER_DESC	"Generic UIO driver for PCI 2.3 devices (modified by T.S.)"
  
  struct uio_pci_generic_dev {
  	struct uio_info info;
***************
*** 122,127 ****
--- 122,197 ----
  	return err;
  }
  
+ /* From Tom Lyon's patch */
+ static void uio_do_maps(struct uio_pci_generic_dev *gdev)
+ {
+ 	struct pci_dev *pdev = gdev->pdev;
+ 	struct uio_info *info = &gdev->info;
+ 	int i, j;
+ 	char *name;
+ 
+ 	for (i = 0, j = 0; i < PCI_STD_RESOURCE_END && j < MAX_UIO_MAPS; i++) {
+ 		if (pci_resource_flags(pdev, i) & IORESOURCE_MEM) {
+ 			/* second test should never be possible but be paranoid... */
+ 			if ( pci_resource_len(pdev, i) < PAGE_SIZE || (pci_resource_start(pdev, i) & (PAGE_SIZE - 1 )) ) {
+ 				/* disallow smaller mappings as this could create security problems
+ 				 * (other device's resource in the same page
+ 				 */
+ 				dev_warn( &pdev->dev,
+ 				          "Memory resource %i @08x%llx:0x%04llx not page-aligned;"
+                           " refuse to map. Use 'pci=resource_alignment=' kernel option for this device\n",
+ 				          i,
+ 				          (unsigned long long)pci_resource_start(pdev, i),
+ 				          (unsigned long long)pci_resource_len(pdev, i) );
+ 				continue;
+ 			}
+ 			name = kmalloc(8, GFP_KERNEL);
+ 			if (name == NULL)
+ 				break;
+ 			sprintf(name, "membar%d", i);
+ 			info->mem[j].name = name;
+ 			info->mem[j].addr = pci_resource_start(pdev, i);
+ 			dev_warn( &pdev->dev, "TSILL adding membar%i @0x08%llx\n", i, (unsigned long long)pci_resource_start(pdev, i));
+ 			info->mem[j].size = pci_resource_len(pdev, i);
+ 			info->mem[j].memtype = UIO_MEM_PHYS;
+ 			j++;
+ 		}
+ 	}
+ 	for (i = 0, j = 0; i < PCI_STD_RESOURCE_END &&
+ 			j < MAX_UIO_PORT_REGIONS; i++) {
+ 		if (pci_resource_flags(pdev, i) & IORESOURCE_IO) {
+ 			name = kmalloc(8, GFP_KERNEL);
+ 			if (name == NULL)
+ 				break;
+ 			sprintf(name, "iobar%d", i);
+ 			info->port[j].name = name;
+ 			info->port[j].start = pci_resource_start(pdev, i);
+ 			info->port[j].size = pci_resource_len(pdev, i);
+ 			info->port[j].porttype = UIO_PORT_X86;
+ 			j++;
+ 		}
+ 	}
+ }
+ 
+ static void uio_free_names(struct uio_pci_generic_dev *gdev)
+ {
+ int i;
+ 	for ( i=0; i < MAX_UIO_MAPS; i++ ) {
+ 		if ( gdev->info.mem[i].name ) {
+ 			kfree( gdev->info.mem[i].name );
+ 			gdev->info.mem[i].name    = 0;
+ 			gdev->info.mem[i].memtype = 0;
+ 		}
+ 	}
+ 	for ( i=0; i < MAX_UIO_PORT_REGIONS; i++ ) {
+ 		if ( gdev->info.port[i].name ) {
+ 			kfree( gdev->info.port[i].name );
+ 			gdev->info.port[i].name     = 0;
+ 			gdev->info.port[i].porttype = 0;
+ 		}
+ 	}
+ }
+ 
  static int __devinit probe(struct pci_dev *pdev,
  			   const struct pci_device_id *id)
  {
***************
*** 138,148 ****
  	if (!pdev->irq) {
  		dev_warn(&pdev->dev, "No IRQ assigned to device: "
  			 "no support for interrupts?\n");
  		pci_disable_device(pdev);
  		return -ENODEV;
  	}
! 
  	err = verify_pci_2_3(pdev);
  	if (err)
  		goto err_verify;
  
--- 208,227 ----
  	if (!pdev->irq) {
  		dev_warn(&pdev->dev, "No IRQ assigned to device: "
  			 "no support for interrupts?\n");
+ 		dev_warn(&pdev->dev, "TSILL phase 1.\n");
+ #ifdef TSILL
  		pci_disable_device(pdev);
  		return -ENODEV;
+ #else
+ 		dev_warn(&pdev->dev, "TSILL phase 2.\n");
+ 		err = 0;
+ #endif
  	}
! #ifndef TSILL
! 	else
! #endif
  	err = verify_pci_2_3(pdev);
+ 
  	if (err)
  		goto err_verify;
  
***************
*** 158,163 ****
--- 237,243 ----
  	gdev->info.irq_flags = IRQF_SHARED;
  	gdev->info.handler = irqhandler;
  	gdev->pdev = pdev;
+ 	uio_do_maps(gdev);
  	spin_lock_init(&gdev->lock);
  
  	if (uio_register_device(&pdev->dev, &gdev->info))
***************
*** 166,171 ****
--- 246,252 ----
  
  	return 0;
  err_register:
+ 	uio_free_names(gdev);
  	kfree(gdev);
  err_alloc:
  err_verify:
***************
*** 179,184 ****
--- 260,266 ----
  
  	uio_unregister_device(&gdev->info);
  	pci_disable_device(pdev);
+ 	uio_free_names(gdev);
  	kfree(gdev);
  }
  
